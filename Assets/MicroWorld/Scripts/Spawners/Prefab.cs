using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Serialization;

namespace MicroWorldNS.Spawners
{
    /// <summary>
    /// Reference to prefab to spawn.
    /// This can be a Texture, PrefabGenerator or GameObject.
    /// </summary>
    [HelpURL("https://docs.google.com/document/d/1vjbYEHIz3ImNsSFFh7J9uqYQmq9SOgXeJuz8NxcbzMg/edit?tab=t.0#heading=h.12on9qku4cx6")]
    [Serializable]
    public class Prefab
    {
        [SerializeField, HideInInspector] public string Name;
        string Info => "Render Type: " + RenderType.ToString();

        [Tooltip("Prefab for spawn. Drag a Texture, GameObject or Generator here.")]
        [PreviewIcon(Height = 100, InfoPropertyName = nameof(Info))]
        public UnityEngine.Object prefab = null;

        [Tooltip("The number of different prefabs generated by PrefabGenerator.")]
        [ShowIf(nameof(isGenerator))]
        [Min(1)] public int PrefabsFromGenerator = 5;

        [Tooltip("An additional prefab that will be spawned as a regular GameObject.")]
        [ShowIf(nameof(ShowAddPrefab))]
        public GameObject AdditionalPrefab = null;

        [Tooltip("Allows the system to spawn this prefab.")]
        public bool Enabled = true;

        [Tooltip("Probability that the spawner will be used in the terrain.")]
        [Range(0f, 1f)]
        public float UsageChance = 1;

        [Tooltip("Defines how the prefab will be rendered.")]
        [SerializeField]
        internal RenderType RenderType;

        [Tooltip("Probability of prefab spawning relative to other prefabs of the spawner. From 0 to infinite. It can be greater 1.")]
        [Min(0f)] 
        public float Chance = 1;

        [Tooltip("Probability of a prefab forced appearing again in the same cell.")]
        [Range(0, 1)] 
        public float RepeatChance = 0f;

        [ShowIf(nameof(RenderType), RenderType.TerrainGrass, RenderType.TerrainGrassBillboard, RenderType.TerrainDetail)]
        [Range(1, 5)]
        [Tooltip("Spawn count in one place."), FormerlySerializedAs("SpawnCount")]
        public int Duplicates = 1;

        [Tooltip("If a prefab with an exclusive group is spawned, then another prefab with the same group will not be able to spawn.")]
        public PrefabExclusiveGroups ExclusiveGroups = new PrefabExclusiveGroups();

        [Header("Bunching")]
        [Tooltip("Number of instances in a bunch.")]
        [Min(1f), FormerlySerializedAs("Bunching")]
        public float Bunch = 1;

        [Tooltip("Radius of bunching around initial position (meters).")]
        [ShowIf(nameof(isBunching), true), Min(0.1f), FormerlySerializedAs("BunchingRadius")]
        public float BunchRadius = 1f;

        [Tooltip("Nonlinearity of distribution in a bunch relative to the center.")]
        [ShowIf(nameof(isBunching), true), Min(0), FormerlySerializedAs("BunchingGravity")]
        public float BunchGravity = 1f;

        [Tooltip("Multiplier of an object scale as it moves away from the center of the bunch.")]
        [ShowIf(nameof(isBunching), true), Min(0), FormerlySerializedAs("BunchFall")]
        public float BunchPeripheryScale = 1f;

        [Header("Other")]
        [Tooltip("Spawned object scale.")]
        [Min(0f)] 
        public float Scale = 1;

        [Tooltip("Random deviation from Scale.")]
        [Range(0, 1)] 
        public float ScaleVariance = 0.5f;

        [Tooltip("Radius that the object occupies (meters). Value greater than zero prevents other objects from spawning in the space occupied by this object.")]
        [ReadOnly(nameof(hasAutoExclusiveRadius), Op = DrawIfOp.AllFalse)]
        [Min(0f)] public float ExclusiveRadius = 0;

        [Tooltip("Tint color.")]
        [ShowIf(nameof(RenderType), RenderType.TerrainGrass, RenderType.TerrainGrassBillboard)]
        public Color Color = Color.white;

        [Tooltip("Alternative tint color.")]
        [ShowIf(nameof(RenderType), RenderType.TerrainGrass, RenderType.TerrainGrassBillboard)]
        public Color AltColor = Color.white;//new Color(0.8321599f, 0.7724007f, 0.081435f);

        [Space]
        [Tooltip("Offset of spawned objects along the Y axis over terrain surface (meters).")]
        [ShowIf(nameof(RenderType), RenderType.GameObject, RenderType.TerrainTree, RenderType.GpuInstanced)]
        public float OffsetY = 0;

        [Tooltip("Random deviation from OffsetY (meters).")]
        [ShowIf(nameof(RenderType), RenderType.GameObject, RenderType.TerrainTree, RenderType.GpuInstanced)]
        [Range(0, 3)]
        public float OffsetYVariance = 0f;

        [Tooltip("Rate between surface normal alignment and vertical alignment.")]
        [Range(0, 1)]
        public float Verticality = 1f;

        [Tooltip("Diapason of heights above water level, where spawning is allowed (meters).")]
        public RangeFloat HeightAboveWater = new RangeFloat(0, 100);

        [Tooltip("Additional rotation around Y axis (degrees).")]
        [ShowIf(nameof(AllowCustomRotationY))]
        public float RotateY = 0;

        [Tooltip("A set of flags for fine-tuning spawning.")]
        public PrefabSpawnFeatures Features = PrefabSpawnFeatures.RotateY;

        Texture2D PrefabAsTexture => prefab as Texture2D;
        internal GameObject PrefabAsGO => prefab as GameObject;
        internal GameObject preparedGO;
        internal IPrefabGenerator Generator => prefab as IPrefabGenerator ?? PrefabAsGO?.GetComponent<IPrefabGenerator>();
        bool isGenerator => Generator != null;
        public bool ShowAddPrefab => prefab != null;
        [NonSerialized]
        public GameObject selectedGo;
        IList<GameObject> prefabsFromGenerator;
        public bool NeedToCheckIntersections => Features.HasFlag(PrefabSpawnFeatures.AvoidIntersections) || ExclusiveRadius > float.Epsilon;

        [HideInInspector, NonSerialized]
        public float ProbabilityInSet;

        public float SpawnedScale { get; protected set; }
        public GameObject SpawnedGO { get; protected set; }
        public GameObject SpawnedAddGO { get; protected set; }
        public Quaternion SpawnedRotation { get; protected set; }
        public string HolderKey { get; protected set; }

        DetailPrototype spawnedDetailLayer;
        TreePrototype spawnedTreeLayer;
        GameObject grassMesh;
        int spawnedTreeIndex;
        bool isBunching => Bunch > 1;
        bool hasAutoExclusiveRadius => Features.HasFlag(PrefabSpawnFeatures.AutoExclusiveRadius);
        protected static int UniqueID { get; set; }

        public Prefab Clone()
        {
            //var clone = MemberwiseClone();
            //return clone as Prefab;

            string json = JsonUtility.ToJson(this);
            return (Prefab)JsonUtility.FromJson(json, GetType());
        }

#if UNITY_EDITOR
        public void OnValidate(BaseSpawner spawner)
        {
            // Terrain Grass requires readable textures
            if (prefab is Texture tex)
                Helper.MakeTextureReadable(tex);

            //Features = Features & (Features.RotateY | Features.RotateZ180 | Features.RotateAny | Features.OneAddPrefabPerBunch | Features.AvoidIntersections | Features.DisableCrossFade | Features.KeepInitRotation);
            if (prefab != null)
                Name = (Enabled ? $"[{Chance}] ":"[Disabled] ") + (prefab?.name ?? "Empty");
            else
                Name = (Enabled ? $"[{Chance}] " : "[Disabled] ") + "Empty";

            if (ExclusiveGroups == null)
                ExclusiveGroups = new PrefabExclusiveGroups();

            CalcExclusiveRadius(PrefabAsGO);
        }
#endif

        public void Prepare(MicroWorld builder, Rnd rnd, BaseSpawner spawner)
        {
            var go = PrefabAsGO;
            var gen = Generator;
            prefabsFromGenerator?.Clear();
            spawnedDetailLayer = default;
            spawnedTreeLayer = default;
            spawnedTreeIndex = -1;
            UniqueID = 0;
            grassMesh = null;

            CalcHolderKey(spawner);

            if (ExclusiveGroups == null)
                ExclusiveGroups = new PrefabExclusiveGroups();

            if (gen != null)
            {
                prefabsFromGenerator = gen.GetPrefabs(builder.Seed, PrefabsFromGenerator, builder.TerrainSpawner.TempHolder);
                go = rnd.GetBranch(937345).GetRnd(prefabsFromGenerator);
            }

            // calc RenderType
            var allowed = GetAllowedRenderTypes(go);
            if (!allowed.Contains(RenderType))
                RenderType = allowed.Last();

            if (go)
            {
                CalcExclusiveRadius(go);

                if (gen != null)
                    prefabsFromGenerator.ForEach(p => AdjustMaterials(p));
                else
                    AdjustMaterials(go);

                if (RenderType == RenderType.TerrainDetail)
                {
                    if (gen != null)
                        prefabsFromGenerator.ForEach(p => PrepareMaterial(builder, p));
                    else
                    {
                        //make clone and clone material
                        go = GameObject.Instantiate(go, builder.TerrainSpawner.TempHolder);
                        PrepareMaterial(builder, go);
                        preparedGO = go;
                    }
                }
            }
        }

        static List<string> holderKeyTempList = new List<string>();

        private void CalcHolderKey(BaseSpawner spawner)
        {
            holderKeyTempList.Clear();
            var features = Preferences.Instance.HierarchyFeatures;

            if (features.HasFlag(HierarchyFeatures.GroupPrefabsBySpawner))
                holderKeyTempList.Add(spawner.name);

            if (features.HasFlag(HierarchyFeatures.GroupPrefabsByName))
            if (prefab != null && !prefab.name.IsNullOrEmpty())
                holderKeyTempList.Add(prefab.name);

            if (features.HasFlag(HierarchyFeatures.GroupPrefabsBySemantic))
            if (spawner is CellSpawner cs)
                holderKeyTempList.Add(cs.Semantic.ToString());

            if (features.HasFlag(HierarchyFeatures.GroupPrefabsByComment))
            if (spawner is CellSpawner cs && !cs.Comment.IsNullOrEmpty())
                holderKeyTempList.Add(cs.Comment.ToString());

            if (features.HasFlag(HierarchyFeatures.GroupPrefabsByTags))
            if (prefab is GameObject go)
                holderKeyTempList.Add(go.tag);

            if (holderKeyTempList.Count == 0)
                HolderKey = features.HasFlag(HierarchyFeatures.GroupPrefabsByCells) ? "" : "Default";
            else
                HolderKey = string.Join("_", holderKeyTempList);
        }

        protected void CalcExclusiveRadius(GameObject go)
        {
            if (!hasAutoExclusiveRadius)
                return;
            if (go == null)
                return;

            var bounds = Helper.GetTotalBounds(go);
            var size = bounds.size * Scale;
            var diagonal = Features.HasFlag(PrefabSpawnFeatures.RotateAny) ? size.magnitude : size.XZ().magnitude;
            ExclusiveRadius = diagonal / 2;
        }

        private void AdjustMaterials(GameObject go)
        {
            if (RenderType == RenderType.GameObject || RenderType == RenderType.GpuInstanced)
                return;// do not change GameObject materials

            if (!Preferences.Instance.Features.HasFlag(PreferncesFeatures.OptimizeShadersRenderQueue))
                return;

            // performance optimization: change render queue to Geomtery for all MeshRenderers in prefab
            var mrs = go.GetComponentsInChildren<MeshRenderer>();

            foreach (var mr in mrs)
            if (mr != null)
            foreach (var mat in mr.sharedMaterials)
            if (mat != null)
                mat.renderQueue = 2000;// geometry
        }

        private void PrepareMaterial(MicroWorld builder, GameObject go)
        {
            var mr = go.GetComponent<MeshRenderer>();
            if (mr != null && mr.sharedMaterial)
            {
                var originalMat = mr.sharedMaterial;
                if (builder.CreatedMaterials.TryGetValue(originalMat, out var mat))
                {
                    mr.sharedMaterial = mat;
                    return;
                }
                mat = mr.sharedMaterial = GameObject.Instantiate(mr.sharedMaterial);
                var dist = builder.Terrain.detailObjectDistance;
                mat.SetFloat("_ViewDist", dist);
                if (Preferences.Instance.Features.HasFlag(PreferncesFeatures.OptimizeShadersRenderQueue))
                    mat.renderQueue = 2000;
                builder.CreatedMaterials.Add(originalMat, mat);
            }
        }

        private IEnumerable<RenderType> GetAllowedRenderTypes(GameObject go)
        {
            // TerrainGrass
            if (PrefabAsTexture != null) { yield return RenderType.TerrainGrassBillboard; yield return RenderType.TerrainGrass; yield break; }

            // None
            if (prefab == null) { yield return RenderType; yield break; }// keep current render type
            if (go == null) { yield return RenderType.None; yield break; }

            var collider = go.GetComponentInChildren<Collider>();
            var hasLODs = go.GetComponentInChildren<LODGroup>();
            var hasMeshRendererItself = go.GetComponent<MeshRenderer>();
            var hasChildren = go.transform.childCount > 0;
            var hasOneMatItself = hasMeshRendererItself == null ? false : hasMeshRendererItself.sharedMaterials.Length == 1;
            var hasCollider = collider != null;

            // TerrainTree
            yield return RenderType.TerrainTree;

            // GameObject
            yield return RenderType.GameObject;

            // GpuInstanced
            if (hasMeshRendererItself && !hasLODs && !hasCollider && !hasChildren) 
                yield return RenderType.GpuInstanced;

            // TerrainDetail
            if (hasMeshRendererItself && hasOneMatItself && !hasLODs && !hasCollider && !hasChildren)
                yield return RenderType.TerrainDetail;
        }

        public void SelectGO(Rnd rnd)
        {
            selectedGo = preparedGO == null ? PrefabAsGO : preparedGO;
            if (Generator != null)
                selectedGo = rnd.GetRnd(prefabsFromGenerator);
        }

        private RotationType GetRotationType()
        {
            if (Features.HasFlag(PrefabSpawnFeatures.RotateAny)) 
                return RotationType.Any;

            if (Features.HasFlag(PrefabSpawnFeatures.RotateY))
            {
                if (Features.HasFlag(PrefabSpawnFeatures.RotateZ180))
                    return RotationType.AroundYZ180;
                return RotationType.AroundY;
            };

            if (Features.HasFlag(PrefabSpawnFeatures.RotateBySurfaceNormal))
                return RotationType.NormalToSurface;

            return RotationType.None;
        }

        private bool AllowCustomRotationY
        {
            get
            {
                switch (RenderType)
                {
                    case RenderType.GameObject:
                    case RenderType.GpuInstanced:
                        break;
                    default: return false;
                }

                switch (GetRotationType())
                {
                    case RotationType.None:
                    case RotationType.NormalToSurface:
                        break;
                    default: return false;
                }

                return true;
            }
        }

        public void Spawn(MicroWorld builder, Vector2Int hex, Vector3 pos, Vector3 faceDir, float addScale, float offsetY, Rnd rnd)
        {
            SpawnedScale = 1;
            SpawnedRotation = Quaternion.identity;
            SpawnedGO = null;
            SpawnedAddGO = null;

            if (selectedGo == null)
                SelectGO(rnd);

            if (!builder.Terrain.terrainData.bounds.Contains(pos))
                return;

            switch (RenderType)
            {
                case RenderType.TerrainDetail: SpawnTerrainDetail(builder, pos, addScale, rnd); break;
                case RenderType.TerrainGrass:
                case RenderType.TerrainGrassBillboard: 
                    if (MicroWorldHelper.Pipeline == Pipeline.HDRP)
                        SpawnTerrainGrassAsMesh(builder, pos, rnd);
                    else
                        SpawnTerrainGrass(builder, pos, rnd); 
                    break;
                case RenderType.TerrainSurface: SpawnSurface(builder, pos); break;
                case RenderType.TerrainTree: SpawnTree(builder, pos, addScale, offsetY, rnd); break;
                case RenderType.GameObject: SpawnGameObject(builder, pos, hex, faceDir, addScale, offsetY, rnd); break;
                case RenderType.GpuInstanced: SpawnGpuInstanced(builder, pos, faceDir, addScale, offsetY, rnd); break;
            }

            if (!Features.HasFlag(PrefabSpawnFeatures.OneAddPrefabPerBunch))
                SpawnAddGameObject(builder, pos, hex, faceDir, offsetY, rnd);
        }

        private void SpawnGpuInstanced(MicroWorld builder, Vector3 pos, Vector3 faceDir, float addScale, float offsetY, Rnd rnd)
        {
            var mr = selectedGo?.GetComponent<MeshRenderer>();

            // calc pos, rot and scale 
            var obj = Manipulator.Get(builder.Terrain.transform);
            obj.position = pos + offsetY * Vector3.up;
            if (!Features.HasFlag(PrefabSpawnFeatures.KeepInitRotation))
                obj.rotation = Quaternion.LookRotation(faceDir, Vector3.up);
            SpawnedScale = MicroWorldHelper.GetScale(Scale * addScale, ScaleVariance, rnd);
            obj.localScale = mr.transform.lossyScale;
            obj.localScale *= SpawnedScale;

            var n = builder.TerrainSpawner.GetNormal(pos);// TODO: cache in static, or pass into method
            var rotType = GetRotationType();
            SpawnedRotation = obj.gameObject.Rotate(n, faceDir, Verticality, rotType, rnd, RotateY, rotType == RotationType.None, Features.HasFlag(PrefabSpawnFeatures.KeepInitRotation));

            var layer = builder.TerrainLayersBuilder.SpawnGpuInstanced(mr, obj.localToWorldMatrix);
        }

        private void SpawnGameObject(MicroWorld builder, Vector3 pos, Vector2Int hex, Vector3 faceDir, float addScale, float offsetY, Rnd rnd)
        {
            // TODO: use Camera.layerCullDistances to spawn small details but out of TerrainDetailLayer

            var rot = Features.HasFlag(PrefabSpawnFeatures.KeepInitRotation) ? selectedGo.transform.rotation : Quaternion.LookRotation(faceDir, Vector3.up);
            var obj = GameObject.Instantiate(selectedGo, pos + offsetY * Vector3.up, rot, builder.TerrainLayersBuilder.GetHolder(this, hex));
            PrepareName(obj);
            SpawnedScale = MicroWorldHelper.GetScale(Scale * addScale, ScaleVariance, rnd);
            obj.transform.localScale *= SpawnedScale;

            var n = builder.TerrainSpawner.GetNormal(pos);// TODO: cache in static, or pass into method
            var rotType = GetRotationType();
            SpawnedRotation = obj.Rotate(n, faceDir, Verticality, rotType, rnd, RotateY, rotType == RotationType.None, Features.HasFlag(PrefabSpawnFeatures.KeepInitRotation));

            var info = obj.GetOrAddComponent<SpawnedObjInfo>();
            info.OffsetY = offsetY;
            info.UniqueID = UniqueID;

            SpawnedGO = obj;
        }

        public void SpawnAddGameObject(MicroWorld builder, Vector3 pos, Vector2Int hex, Vector3 faceDir, float offsetY, Rnd rnd)
        {
            if (AdditionalPrefab == null)
                return;

            var obj = GameObject.Instantiate(AdditionalPrefab, pos + offsetY * Vector3.up, Quaternion.LookRotation(faceDir, Vector3.up), builder.TerrainLayersBuilder.GetHolder(this, hex));
            PrepareName(obj);
            obj.transform.localScale *= SpawnedScale;
            if (RenderType == RenderType.GameObject)
                obj.transform.rotation = SpawnedRotation;

            var info = obj.GetOrAddComponent<SpawnedPrefabInfo>();
            info.RenderType = RenderType;
            info.DetailLayer = spawnedDetailLayer;
            info.TreeLayer = spawnedTreeLayer;
            info.TreeIndex  = spawnedTreeIndex;
            info.SpawnedObj = SpawnedGO;

            var objInfo = obj.GetOrAddComponent<SpawnedObjInfo>();
            objInfo.OffsetY = offsetY;
            objInfo.UniqueID = UniqueID;

            SpawnedAddGO = obj;
        }

        private void PrepareName(GameObject obj)
        {
            UniqueID++;
            string originalName = obj.name;
            const int cloneSuffixLength = 7;

            if (originalName.EndsWith("(Clone)"))
                originalName = originalName.Substring(0, originalName.Length - cloneSuffixLength);

            if (Preferences.Instance.HierarchyFeatures.HasFlag(HierarchyFeatures.AddIdToPrefabName))
                obj.name = string.Concat(originalName, "_ID", UniqueID);
            else
                obj.name = originalName;
        }

        private void SpawnTree(MicroWorld builder, Vector3 pos, float addScale, float offsetY, Rnd rnd)
        {
            SpawnedScale = MicroWorldHelper.GetScale(Scale * addScale, ScaleVariance, rnd);

            var treeSample = new TreeInstance();
            treeSample.widthScale = SpawnedScale;
            treeSample.heightScale = SpawnedScale;
            treeSample.position = pos + offsetY * Vector3.up;
            treeSample.color = Color;
            treeSample.lightmapColor = AltColor;

            var layer = spawnedTreeLayer = builder.TerrainLayersBuilder.SpawnTree(selectedGo, treeSample);
            spawnedTreeIndex = treeSample.prototypeIndex;

            // adjust layer
            layer.bendFactor = 0f;
        }

        private void SpawnSurface(MicroWorld builder, Vector3 pos)
        {           
        }

        private void SpawnTerrainGrass(MicroWorld builder, Vector3 pos, Rnd rnd)
        {
            var layer = spawnedDetailLayer = builder.TerrainLayersBuilder.SpawnGrass(PrefabAsTexture, pos, Duplicates);
            const float noiseSpread = 1.4f;
            var sx = Preferences.Instance.ScaleGrassWidth;
            var sy = Preferences.Instance.ScaleGrassHeight;

            // adjust layer
            if (layer.noiseSpread != noiseSpread)
            {
                SpawnedScale = 0.5f * Scale;
                var scaleBounds = MicroWorldHelper.GetScaleBounds(SpawnedScale, ScaleVariance);

                layer.minWidth = scaleBounds.x * sx;
                layer.maxWidth = scaleBounds.y * sx;
                layer.minHeight = scaleBounds.x * sy;
                layer.maxHeight = scaleBounds.y * sy;
                layer.renderMode = RenderType == RenderType.TerrainGrassBillboard ? DetailRenderMode.GrassBillboard : DetailRenderMode.Grass;
                layer.healthyColor = Color.withAlpha(0.1f);
                layer.dryColor = AltColor.withAlpha(0.1f);
                layer.noiseSpread = noiseSpread;

#if UNITY_2022_2_OR_NEWER
                layer.alignToGround = 1 - Verticality;
                layer.positionJitter = 0.5f;
                layer.density = 100;
#endif
            }
        }

        private void SpawnTerrainGrassAsMesh(MicroWorld builder, Vector3 pos, Rnd rnd)
        {
            // create mesh for grass
            if (grassMesh == null)
            {
                // becuase HDRP does not support terrain grass, replace it with a mesh
                grassMesh = GameObject.Instantiate(Resources.Load<GameObject>("Grass"), builder.TerrainSpawner.TempHolder);
                var mr = grassMesh.GetComponent<MeshRenderer>();
                mr.sharedMaterial = GameObject.Instantiate(mr.sharedMaterial);
                mr.sharedMaterial.mainTexture = PrefabAsTexture;
                AdjustMaterials(grassMesh);
            }

            //
            var layer = spawnedDetailLayer = builder.TerrainLayersBuilder.SpawnDetail(grassMesh, pos + Vector3.up, Duplicates);
            const float noiseSpread = 1.4f;
            var scale = grassMesh.transform.lossyScale.x;
            var sx = Preferences.Instance.ScaleGrassWidth * scale;
            var sy = Preferences.Instance.ScaleGrassHeight * scale;

            // adjust layer
            if (layer.noiseSpread != noiseSpread)
            {
                SpawnedScale = 0.5f * Scale;
                var scaleBounds = MicroWorldHelper.GetScaleBounds(SpawnedScale, ScaleVariance);

                layer.minWidth = scaleBounds.x * sx;
                layer.maxWidth = scaleBounds.y * sx;
                layer.minHeight = scaleBounds.x * sy;
                layer.maxHeight = scaleBounds.y * sy;
                layer.renderMode = DetailRenderMode.VertexLit;
                layer.healthyColor = Color.withAlpha(0.1f);
                layer.dryColor = AltColor.withAlpha(0.1f);
                layer.noiseSpread = noiseSpread;

#if UNITY_2022_2_OR_NEWER
                layer.alignToGround = 1 - Verticality;
                layer.positionJitter = 0.5f;
                layer.density = 100;
#endif
            }
        }

        private void SpawnTerrainDetail(MicroWorld builder, Vector3 pos, float addScale, Rnd rnd)
        {
            var layer = spawnedDetailLayer = builder.TerrainLayersBuilder.SpawnDetail(selectedGo, pos, Duplicates);

            const float noiseSpread = 110;

            // adjust layer
            if (layer.noiseSpread != noiseSpread)
            {
                SpawnedScale = Scale * addScale;
                var scaleBounds = MicroWorldHelper.GetScaleBounds(SpawnedScale, ScaleVariance);

                layer.minWidth = scaleBounds.x;
                layer.maxWidth = scaleBounds.y;
                layer.minHeight = scaleBounds.x;
                layer.maxHeight = scaleBounds.y;
                layer.renderMode = DetailRenderMode.VertexLit;
                layer.useInstancing = true;
                layer.noiseSpread = noiseSpread;

#if UNITY_2022_2_OR_NEWER
                layer.alignToGround = 1 - Verticality;
                layer.positionJitter = 0.5f;
                layer.density = 100;
#endif
            }
        }
    }

    [Flags]
    public enum PrefabSpawnFeatures : int
    {
        None = 0x0,
        RotateY = 0x1,
        RotateZ180 = 0x80,
        RotateAny = 0x2,
        RotateBySurfaceNormal = 0x100,
        KeepInitRotation = 0x4,
        AvoidIntersections = 0x40,
        AutoExclusiveRadius = 0x20,
        //_not_used3 = 0x20,
        LiftToWaterLevel = 0x8,
        SpawnAtCellLevel = 0x10,
        GenRepeatDifference = 0x200,
        OneAddPrefabPerBunch = 0x400
    }

    public enum RenderType
    {
        None = 0,
        TerrainSurface = 2, 
        TerrainGrass = 3, 
        TerrainGrassBillboard = 4, 
        TerrainDetail = 5, 
        TerrainTree = 6, 
        GameObject = 7, 
        GpuInstanced = 8
    }

    public enum RotationType
    {
        None, Any, AroundY, AroundYZ180, NormalToSurface
    }

    [Serializable]
    public class PrefabExclusiveGroups
    {
        [Tooltip("Exclusive group for the whole terrain.")]
        public string TerrainExclusiveGroup = "";
        [Tooltip("Exclusive group for the cell.")]
        public string CellExclusiveGroup = "";
        [Tooltip("Exclusive group for the sector of cell.")]
        public string SectorExclusiveGroup = "";
    }

    static class PrefabSetHelper
    {
        public static IEnumerator Prepare(this IList<Prefab> prefabs, MicroWorld builder, Rnd rnd, BaseSpawner spawner)
        {
            var sumChance = 0f;
            foreach (var p in prefabs)
            {
                if (p == null)
                    continue;

                var prefabRnd = rnd.GetBranch(p.prefab == null ? "" : p.prefab.name, 232434);
                if (!p.Enabled || p.prefab == null || !prefabRnd.Bool(p.UsageChance))
                {
                    p.ProbabilityInSet = 0f;
                    continue;
                }

                p.Prepare(builder, prefabRnd, spawner);

                var isAllowed = p.Enabled && p.RenderType != RenderType.None;
                p.ProbabilityInSet = isAllowed ? p.Chance : 0;
                sumChance += p.Chance;
                yield return null;
            }

            if (sumChance > float.Epsilon)
                foreach (var p in prefabs)
                    p.ProbabilityInSet /= sumChance;
        }
    }
}
